using System;
using System.Threading.Tasks;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Collections.Immutable;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using Noggog;
using RecombinePatch.Ingress;
using RecombinePatch.Ingress.DtoV1;

namespace RecombinePatch
{
    class Program
    {
        static Lazy<Settings> LazySettings = new();
        static volatile bool SynthesisMode = false;

        public static async Task<int> Main(string[] args)
        {
            if (args.Contains("--DataFolderPath"))
            {
                SynthesisMode = true;
            }

            return await SynthesisPipeline.Instance
                .SetAutogeneratedSettings(
                    "Settings",
                    "settings.json",
                    out LazySettings)
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Recombine.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {   
            if (LazySettings.Value.ExternalConfigurationPath == null)
                throw new Exception("External Config Path should be set");
            var externalConfigDir = new DirectoryInfo(LazySettings.Value.ExternalConfigurationPath);
            if (!externalConfigDir.Exists)
                externalConfigDir.Create();
            if (!externalConfigDir.Exists)
                throw new Exception("External Config Path is pointing to invalid location (failed to create a folder there)");
            var fullConfigDir = new DirectoryInfo(
                SynthesisMode
                    ? Path.Join(externalConfigDir.FullName, "Synthesis", state.GameRelease.ToString())
                    : Path.Join(externalConfigDir.FullName, "Standalone", state.GameRelease.ToString())
            );
            if (!fullConfigDir.Exists)
                fullConfigDir.Create();
            string ingressFileName = "ingress.json";
            var ingressFilePath = new FileInfo(Path.Join(fullConfigDir.FullName, ingressFileName));
            
            using var loadOrder = state.LoadOrder;

            var enabledAndExisting = loadOrder.PriorityOrder
                .OnlyEnabledAndExisting()
                .ToImmutableArray();
            var linkCache = loadOrder.ToImmutableLinkCache<ISkyrimMod, ISkyrimModGetter>(); 
            var ingressCache = new IngressCache(linkCache);

            var pluginsDto = enabledAndExisting
                .Reverse()
                .Select(m => MapperV1.ModV1(m.ModKey))
                .ToImmutableArray();
            
            foreach (var item in enabledAndExisting.WinningOverrides<ILeveledItemGetter>())
            {
                if (true || item.EditorID == "DeathItemDraugr")
                // if (item.EditorID == "DeathItemGiant")
                {
                    if (item.Flags.And(LeveledItem.Flag.UseAll) > 0)
                    {
                        var group = IngressMagic.ArmorGroupFromLeveledList(ingressCache, item);
                        // if (group != null)
                        // {
                        //     Console.WriteLine($"Set {item.FormKey} {item.EditorID} {group.ListChance}:");
                        //     foreach (var (formKey, groupItem) in group.Items)
                        //     {
                        //         Console.WriteLine($"  - {formKey} {groupItem.Item.EditorID}");
                        //         groupItem.WriteLine("    ");
                        //     }
                        // }
                    }
                }
            }

            var ingressDto = new RootV1(
                "1.0.0",
                state.GameRelease.ToString(),
                state.DataFolderPath,
                MapperV1.ModV1(state.PatchMod.ModKey),
                pluginsDto
            );
            var ingressDtoStr = JsonSerializer.Serialize(ingressDto, new JsonSerializerOptions
            {
                WriteIndented = true,
                NumberHandling = JsonNumberHandling.Strict,
                IgnoreNullValues = false,
            });
            
            Console.WriteLine($"Writing {ingressFilePath.FullName}...");
            File.WriteAllText(ingressFilePath.FullName, ingressDtoStr, Encoding.UTF8);
            Console.WriteLine($"Done writing {ingressFilePath.FullName}.");
        }
    }
}

namespace System.Runtime.CompilerServices
{
    [EditorBrowsable(EditorBrowsableState.Never)]
    internal class IsExternalInit{}
}