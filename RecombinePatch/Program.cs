using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Collections.Immutable;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using MessagePack;
using Mutagen.Bethesda.Plugins;
using Noggog;
using RecombinePatch.Ingress;
using RecombinePatch.Ingress.DtoV1;

namespace RecombinePatch
{
    class Program
    {
        static Lazy<Settings> LazySettings = new();
        static volatile bool SynthesisMode = false;

        public static async Task<int> Main(string[] args)
        {
            if (args.Contains("--DataFolderPath"))
            {
                SynthesisMode = true;
            }

            return await SynthesisPipeline.Instance
                .SetAutogeneratedSettings(
                    "Settings",
                    "settings.json",
                    out LazySettings)
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Recombine.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {   
            if (LazySettings.Value.ExternalConfigurationPath == null)
                throw new Exception("External Config Path should be set");
            var externalConfigDir = new DirectoryInfo(LazySettings.Value.ExternalConfigurationPath);
            if (!externalConfigDir.Exists)
                externalConfigDir.Create();
            if (!externalConfigDir.Exists)
                throw new Exception("External Config Path is pointing to invalid location (failed to create a folder there)");
            var fullConfigDir = new DirectoryInfo(
                SynthesisMode
                    ? Path.Join(externalConfigDir.FullName, "Synthesis", state.GameRelease.ToString())
                    : Path.Join(externalConfigDir.FullName, "Standalone", state.GameRelease.ToString())
            );
            if (!fullConfigDir.Exists)
                fullConfigDir.Create();
            string ingressJsonFileName = "ingress.json";
            var ingressJsonFilePath = new FileInfo(Path.Join(fullConfigDir.FullName, ingressJsonFileName));
            
            string ingressMpFileName = "ingress.mp";
            var ingressMpFilePath = new FileInfo(Path.Join(fullConfigDir.FullName, ingressMpFileName));
            
            using var loadOrder = state.LoadOrder;

            var enabledAndExisting = loadOrder.PriorityOrder
                .OnlyEnabledAndExisting()
                .ToImmutableArray();
            var linkCache = loadOrder.ToImmutableLinkCache<ISkyrimMod, ISkyrimModGetter>(); 
            var ingressCache = new IngressCache(linkCache);

            var pluginsByModKey = enabledAndExisting
                .Reverse()
                .Select((m, i) => new { Key = m.ModKey, Plugin = MapperV1.ModV1((ushort)i, m.ModKey) })
                .ToImmutableDictionary(p => p.Key, p => p.Plugin);

            Func<FormKey, FormKeyV1> mapFormKey = (key) => pluginsByModKey.TryGetValue(key.ModKey, out var plugin)
                ? new FormKeyV1(plugin.Index, key.ID)
                : throw new Exception("Detected use of undefined plugin ID");

            var groupIds = new Dictionary<FormKey, uint>();
            Func<FormKey, uint> mapGroupIndex = (key) =>
            {
                if (groupIds.TryGetValue(key, out var gid)) return gid;
                gid = (uint)groupIds.Count;
                groupIds.Add(key, gid);
                return gid;
            };

            var itemDirectLeveledLists = new Dictionary<FormKeyV1, List<uint>>();
            var itemOutfits = new Dictionary<FormKeyV1, List<uint>>();
            var itemContainers = new Dictionary<FormKeyV1, List<uint>>();
            
            var leveledLists = new List<LeveledItemV1>();
            var outfits = new List<OutfitV1>();
            var containers = new List<ContainerV1>();
            
            var itemGroups = new List<ItemGroupV1>();

            foreach (var leveledItem in enabledAndExisting.WinningOverrides<ILeveledItemGetter>())
            {
                var leveledListMappedFormKey = mapFormKey(leveledItem.FormKey);
                var group = IngressMagic.GroupFromLeveledList(ingressCache, leveledItem);
                uint? groupIndex = null;
                if (group != null)
                {
                    groupIndex = mapGroupIndex(group.FormKey);
                    
                    var groupEntries = new List<ItemGroupEntryV1>(group.Items.Count);
                    
                    foreach (var groupItem in group.Items)
                    {
                        var mappedFormKey = mapFormKey(groupItem.Value.Item.FormKey);
                        
                        if (groupItem.Value.ActualEntryCount > 0)
                        {
                            if (itemDirectLeveledLists.TryGetValue(mappedFormKey, out var entry2))
                            {
                                entry2.Add(groupIndex.Value);
                            }
                            else
                            {
                                itemDirectLeveledLists.Add(mappedFormKey, new[] { groupIndex.Value }.ToList());
                            }
                        }

                        groupEntries.Add(new ItemGroupEntryV1(
                            mappedFormKey,
                            groupItem.Value.Drops.Flat,
                            groupItem.Value.Drops.Leveled?
                                .Items
                                .Select(ch => new LevelChanceV1(ch.Key.From ?? 1, ch.Value))
                                .ToArray(),
                            groupItem.Value.DropBranches.Keys.Select(k => mapGroupIndex(k)).ToArray()
                        ));
                    }
                    
                    itemGroups.Add(new ItemGroupV1(
                        groupIndex.Value, 
                        leveledList: leveledListMappedFormKey, 
                        outfit: null, 
                        container: null, 
                        groupEntries));
                }

                leveledLists.Add(
                    new LeveledItemV1(
                        leveledListMappedFormKey,
                        groupIndex,
                        leveledItem.EditorID
                    ));
            }
            
            foreach (var outfitItem in enabledAndExisting.WinningOverrides<IOutfitGetter>())
            {
                var outfitMappedFormKey = mapFormKey(outfitItem.FormKey);
                var group = IngressMagic.GroupFromOutfit(ingressCache, outfitItem);
                uint? groupIndex = null;
                if (group != null)
                {
                    groupIndex = mapGroupIndex(group.FormKey);
                    
                    var groupEntries = new List<ItemGroupEntryV1>(group.Items.Count);
                    
                    foreach (var groupItem in group.Items)
                    {
                        var mappedFormKey = mapFormKey(groupItem.Value.Item.FormKey);
                        
                        if (itemOutfits.TryGetValue(mappedFormKey, out var entry2))
                        {
                            entry2.Add(groupIndex.Value);
                        }
                        else
                        {
                            itemOutfits.Add(mappedFormKey, new[] { groupIndex.Value }.ToList());
                        }

                        groupEntries.Add(new ItemGroupEntryV1(
                            mappedFormKey,
                            groupItem.Value.Drops.Flat,
                            groupItem.Value.Drops.Leveled?
                                .Items
                                .Select(ch => new LevelChanceV1(ch.Key.From ?? 1, ch.Value))
                                .ToArray(),
                            groupItem.Value.DropBranches.Keys.Select(k => mapGroupIndex(k)).ToArray()
                        ));
                    }
                    
                    itemGroups.Add(new ItemGroupV1(
                        groupIndex.Value, 
                        leveledList: null, 
                        outfit: outfitMappedFormKey, 
                        container: null, 
                        groupEntries));
                }

                outfits.Add(
                    new OutfitV1(
                        outfitMappedFormKey,
                        groupIndex,
                        outfitItem.EditorID
                    ));
            }
            
            foreach (var containerItem in enabledAndExisting.WinningOverrides<IContainerGetter>())
            {
                var containerMappedFormKey = mapFormKey(containerItem.FormKey);
                var group = IngressMagic.GroupFromContainer(ingressCache, containerItem);
                uint? groupIndex = null;
                if (group != null)
                {
                    groupIndex = mapGroupIndex(group.FormKey);
                    
                    var groupEntries = new List<ItemGroupEntryV1>(group.Items.Count);
                    
                    foreach (var groupItem in group.Items)
                    {
                        var mappedFormKey = mapFormKey(groupItem.Value.Item.FormKey);
                        
                        if (itemContainers.TryGetValue(mappedFormKey, out var entry2))
                        {
                            entry2.Add(groupIndex.Value);
                        }
                        else
                        {
                            itemContainers.Add(mappedFormKey,
                                new[] { groupIndex.Value }.ToList());
                        }

                        groupEntries.Add(new ItemGroupEntryV1(
                            mappedFormKey,
                            groupItem.Value.Drops.Flat,
                            groupItem.Value.Drops.Leveled?
                                .Items
                                .Select(ch => new LevelChanceV1(ch.Key.From ?? 1, ch.Value))
                                .ToArray(),
                            groupItem.Value.DropBranches.Keys.Select(k => mapGroupIndex(k)).ToArray()
                        ));
                    }
                    
                    itemGroups.Add(new ItemGroupV1(
                        groupIndex.Value, 
                        leveledList: null, 
                        outfit: null, 
                        container: containerMappedFormKey, 
                        groupEntries));
                }

                containers.Add(
                    new ContainerV1(
                        containerMappedFormKey,
                        groupIndex,
                        containerItem.EditorID,
                        containerItem.Name?.String
                    ));
            }

            var armorItems = enabledAndExisting.WinningOverrides<IArmorGetter>()
                .Select(g =>
                {
                    var key = mapFormKey(g.FormKey);
                    return new ArmorV1(
                        mapFormKey(g.FormKey),
                        g.EditorID,
                        g.Name?.String,
                        itemOutfits.TryGetValue(key, out var lists)
                            ? lists
                            : new List<uint>(),
                        itemContainers.TryGetValue(key, out var lists2)
                            ? lists2
                            : new List<uint>(),
                        itemDirectLeveledLists.TryGetValue(key, out var lists3)
                            ? lists3
                            : new List<uint>()
                    );
                })
                .ToArray();
            
            var weaponItems = enabledAndExisting.WinningOverrides<IWeaponGetter>()
                .Select(g =>
                {
                    var key = mapFormKey(g.FormKey);
                    return new WeaponV1(
                        key,
                        g.EditorID,
                        g.Name?.String,
                        itemOutfits.TryGetValue(key, out var lists)
                            ? lists
                            : new List<uint>(),
                        itemContainers.TryGetValue(key, out var lists2)
                            ? lists2
                            : new List<uint>(),
                        itemDirectLeveledLists.TryGetValue(key, out var lists3)
                            ? lists3
                            : new List<uint>()
                    );
                })
                .ToArray();

            var ingressDto = new RootV1(
                1,
                state.GameRelease.ToString(),
                state.DataFolderPath,
                pluginsByModKey.Values.First(v => v.ModKey.ToString() == state.PatchMod.ModKey),
                pluginsByModKey.Values.OrderBy(v => v.Index).ToArray(),
                armorItems,
                weaponItems,
                Array.Empty<MiscV1>(),
                leveledLists,
                outfits,
                containers,
                itemGroups
            );

            if (false)
            {
                // Write to json. WARNING. Output can be big.
                
                Console.WriteLine($"Writing {ingressJsonFilePath.FullName}...");
                var jsonOptions = new JsonSerializerOptions
                {
                    NumberHandling = JsonNumberHandling.Strict,
                    IgnoreNullValues = true,
                    WriteIndented = true,
                    IncludeFields = true,
                };

                using (var fileStream = new FileStream(ingressJsonFilePath.FullName, FileMode.Truncate))
                {
                    JsonSerializer.SerializeAsync(fileStream, ingressDto, jsonOptions).Wait();
                }

                Console.WriteLine($"Done writing {ingressJsonFilePath.FullName}.");
            }

            var tmpFileName = $"{ingressMpFilePath.FullName}.tmp";
            var oldFileName = $"{ingressMpFilePath.FullName}.old";
            
            Console.WriteLine($"Writing {tmpFileName}...");
            
            var fileInfo = new FileInfo(tmpFileName);
            if (fileInfo.Exists)
            {
                fileInfo.Delete();
            }

            using (var fileStream = new FileStream(fileInfo.FullName, FileMode.CreateNew))
            {
                MessagePackSerializer.SerializeAsync(fileStream, ingressDto).Wait();
            }

            FileInfo fileInfoOld;
            
            if (ingressMpFilePath.Exists)
            {
                fileInfoOld = new FileInfo(oldFileName);
                if (fileInfoOld.Exists)
                {
                    fileInfoOld.Delete();
                }

                Console.WriteLine($"Renaming {ingressMpFilePath.FullName} to {oldFileName}...");
                File.Move(ingressMpFilePath.FullName, oldFileName);
            }

            Console.WriteLine($"Renaming {fileInfo.FullName} to {ingressMpFilePath.FullName}...");
            File.Move(fileInfo.FullName, ingressMpFilePath.FullName);

            fileInfoOld = new FileInfo(oldFileName);
            if (fileInfoOld.Exists)
            {
                fileInfoOld.Delete();
            }
        }
    }
}

namespace System.Runtime.CompilerServices
{
    [EditorBrowsable(EditorBrowsableState.Never)]
    internal class IsExternalInit{}
}